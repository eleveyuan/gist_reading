# 抽象：进程

## 家庭作业

Q1: 用以下标志运行程序：./process-run.py -l 5:100,5:100.CPU 利用率（CPU 使用时间的百分比）应该是多少？为什么你知道这一点？利用－c 标记查看你的答案是否正确

A: -l参数中是一个逗号分隔的进程列表，其中5为指令数，100为进行cpu的可能性, 所以这里可以知道cpu的利用率为100%

---

Q2: 现在用这些标志运行： ./process-run.py -l 4:100,1:0 这些标志指定了一个包含 4 条指令的进程(都要使用 CPU),并且只是简单地发出 IO 并等待它完成。完成这两个进程需要多长时间?利用 c 检查你的答案是否正确。

A: 从完成4条cpu指令，到开始1个io任务时，默认io阻塞5个时钟，所以整个需要10个时钟，此时cpu出于空闲状态

---

Q3: 现在交换进程的顺序： ./process-run.py -l 1:0,4:100 现在发生了什么？交换顺序是否重要？为什么？同样，用 -c 看看你的答案是否正确。

A: 由2可知，io先行会进入阻塞态，为了避免cpu空闲，切换进程给cpu跑，io阻塞5个时钟，4个时钟跑完，加上io开启时钟以及阻塞时钟，总共6个时钟。可以看到整体上效率更好了，避免了cpu空闲。

--- 

Q4: 现在探索另一些标志。一个重要的标志是 -S，它决定了当进程发出 IO 时系统如何反应。将标志设置为 SWITCH_ON_END，在进程进行 I/O 操作时,系统将不会切换到另一个进程,而是等待进程完成。当你运行以下两个进程时，会发生什么情况？一个执行 I/O，另一个执行 CPU 工作。（-l 1:0,4:100 -c -S SWITCH_ON_END）

A: SWITCH_ON_END表示当前进程结束，在切换下一个任务，相当于任务串行，导致任务会需要等待io完成。

---

Q5: 现在,运行相同的进程，但切换行为设置，在等待 IO 时切换到另一个进程（-l 1:0,4:100 c-S- SWITCH_ON_IO）现在会发生什么？利用 -c 来确认你的答案是否正确。

A: 程序默认是等待io的，也即默认-S参数为SWITCH_ON_IO，所以效果同第三题

---

Q6： 另一个重要的行为是 IO 完成时要做什么。利用 -I IO_RUN_LATER，当 IO 完成时,发出它的进程不一定马上运行。相反，当时运行的进程一直运行。当你运行这个进程组合时会发生什么？（./process-run.py -l 3:0,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p）系统资源是否被有效利用？

A: io任务较多(io密集型任务)，存在cpu空闲

---

Q7: 现在运行相同的进程,但使用 -I IO_RUN_IMMEDIATE 设置,该设置立即运行发出 IO 的进程。这种行为有何不同？为什么运行一个刚刚完成 IO 的进程会是一个好主意？

A: 运行参数-l 3:0,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p，cpu利用率达到100%。所以这里设置IO_RUN_IMMEDIATE完成上一个io之后，立即切换cpu去请求新的io任务，然后再切换回cpu任务可以充分利用cpu

--- 

Q8: 现在运行一些随机生成的进程,例如 -s 1 -l 3:50,3:50，-s 2 -l 3:50，3:50，-s 3 -l 3:50，3:50 看看你是否能预测追踪记录会如何变化？当你使用 -IORUN_IMMEDIATE 与 -IO RUN LATER 时会发生什么？当你使用 -SWITCHONIO 与 -SWITCHONEND 时会发生什么?

A: 实际运行可知